// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	"fmt"
	"github.com/albedosehen/rwwwrse/internal/config"
	"github.com/albedosehen/rwwwrse/internal/health"
	"github.com/albedosehen/rwwwrse/internal/middleware"
	"github.com/albedosehen/rwwwrse/internal/observability"
	"github.com/albedosehen/rwwwrse/internal/proxy"
	"github.com/albedosehen/rwwwrse/internal/server"
	"github.com/albedosehen/rwwwrse/internal/tls"
	"github.com/google/wire"
	"sync"
	"time"
)

// Injectors from wire.go:

// InitializeApplication creates a fully wired application instance.
// This function will be implemented by Wire code generation.
func InitializeApplication(ctx context.Context) (*Application, error) {
	configConfig, err := config.ProvideConfig()
	if err != nil {
		return nil, err
	}
	loggingConfig, err := config.ProvideLoggingConfig()
	if err != nil {
		return nil, err
	}
	logger := observability.ProvideLogger(loggingConfig)
	metricsConfig, err := config.ProvideMetricsConfig()
	if err != nil {
		return nil, err
	}
	metricsCollector := observability.ProvideMetricsCollector(metricsConfig)
	backendsConfig, err := config.ProvideBackendsConfig()
	if err != nil {
		return nil, err
	}
	router := proxy.ProvideRouter(backendsConfig, logger, metricsCollector)
	backendManager := proxy.ProvideBackendManager(backendsConfig, logger, metricsCollector)
	proxyHandler := proxy.ProvideProxyHandler(router, logger, metricsCollector)
	connectionPool := proxy.ProvideConnectionPool(backendsConfig, logger, metricsCollector)
	serverManager := server.NewServerManager(logger)
	manager, err := tls.NewTLSManager(configConfig, logger, metricsCollector)
	if err != nil {
		return nil, err
	}
	chain := middleware.CreateCompleteMiddlewareChain(configConfig, logger, metricsCollector)
	healthConfig := health.ProvideHealthConfig(configConfig)
	healthChecker := health.NewHealthChecker(healthConfig, logger, metricsCollector)
	healthAggregator := health.NewHealthAggregator(healthChecker, logger, metricsCollector)
	healthReporter := health.NewHealthReporter(healthAggregator, logger, configConfig)
	circuitBreakerConfig := health.ProvideCircuitBreakerConfig(healthConfig)
	circuitBreaker := health.NewCircuitBreaker(circuitBreakerConfig, logger, metricsCollector)
	healthTargetFactory := health.NewHealthTargetFactory(healthChecker, circuitBreaker, logger)
	healthSystem := health.NewHealthSystem(healthChecker, healthAggregator, healthReporter, healthTargetFactory)
	application := ProvideApplication(configConfig, logger, metricsCollector, router, backendManager, proxyHandler, connectionPool, serverManager, manager, chain, healthSystem)
	return application, nil
}

// InitializeApplicationWithConfig creates a fully wired application instance with custom config.
// This function will be implemented by Wire code generation.
func InitializeApplicationWithConfig(ctx context.Context, cfg *config.Config) (*Application, error) {
	loggingConfig := config.ProvideLoggingConfigFromConfig(cfg)
	logger := observability.ProvideLogger(loggingConfig)
	metricsConfig := config.ProvideMetricsConfigFromConfig(cfg)
	metricsCollector := observability.ProvideMetricsCollector(metricsConfig)
	backendsConfig := config.ProvideBackendsConfigFromConfig(cfg)
	router := proxy.ProvideRouter(backendsConfig, logger, metricsCollector)
	backendManager := proxy.ProvideBackendManager(backendsConfig, logger, metricsCollector)
	proxyHandler := proxy.ProvideProxyHandler(router, logger, metricsCollector)
	connectionPool := proxy.ProvideConnectionPool(backendsConfig, logger, metricsCollector)
	serverManager := server.NewServerManager(logger)
	manager, err := tls.NewTLSManager(cfg, logger, metricsCollector)
	if err != nil {
		return nil, err
	}
	chain := middleware.CreateCompleteMiddlewareChain(cfg, logger, metricsCollector)
	healthConfig := health.ProvideHealthConfig(cfg)
	healthChecker := health.NewHealthChecker(healthConfig, logger, metricsCollector)
	healthAggregator := health.NewHealthAggregator(healthChecker, logger, metricsCollector)
	healthReporter := health.NewHealthReporter(healthAggregator, logger, cfg)
	circuitBreakerConfig := health.ProvideCircuitBreakerConfig(healthConfig)
	circuitBreaker := health.NewCircuitBreaker(circuitBreakerConfig, logger, metricsCollector)
	healthTargetFactory := health.NewHealthTargetFactory(healthChecker, circuitBreaker, logger)
	healthSystem := health.NewHealthSystem(healthChecker, healthAggregator, healthReporter, healthTargetFactory)
	application := ProvideApplication(cfg, logger, metricsCollector, router, backendManager, proxyHandler, connectionPool, serverManager, manager, chain, healthSystem)
	return application, nil
}

// wire.go:

// Application represents the complete wired application.
type Application struct {
	Config          *config.Config
	Logger          observability.Logger
	Metrics         observability.MetricsCollector
	Router          proxy.Router
	BackendMgr      proxy.BackendManager
	Handler         proxy.ProxyHandler
	ConnectionPool  proxy.ConnectionPool
	ServerManager   server.ServerManager
	TLSManager      tls.Manager
	MiddlewareChain middleware.Chain
	HealthSystem    *health.HealthSystem

	mu      sync.RWMutex
	running bool
}

// providerSet defines the complete set of providers for dependency icnjection.
var providerSet = wire.NewSet(config.ProvideConfig, config.ProvideLoggingConfig, config.ProvideMetricsConfig, config.ProvideBackendsConfig, observability.ProvideLogger, observability.ProvideMetricsCollector, proxy.ProvideRouter, proxy.ProvideBackendManager, proxy.ProvideProxyHandler, proxy.ProvideConnectionPool, server.ProviderSet, tls.ProviderSet, middleware.ProviderSet, health.ProviderSet, ProvideApplication)

// ProvideApplication creates the main application instance.
func ProvideApplication(
	cfg *config.Config,
	logger observability.Logger,
	metrics observability.MetricsCollector,
	router proxy.Router,
	backendMgr proxy.BackendManager,
	handler proxy.ProxyHandler,
	connectionPool proxy.ConnectionPool,
	serverManager server.ServerManager,
	tlsManager tls.Manager,
	middlewareChain middleware.Chain,
	healthSystem *health.HealthSystem,
) *Application {
	return &Application{
		Config:          cfg,
		Logger:          logger,
		Metrics:         metrics,
		Router:          router,
		BackendMgr:      backendMgr,
		Handler:         handler,
		ConnectionPool:  connectionPool,
		ServerManager:   serverManager,
		TLSManager:      tlsManager,
		MiddlewareChain: middlewareChain,
		HealthSystem:    healthSystem,
	}
}

// Start starts all components of the application.
func (a *Application) Start(ctx context.Context) error {
	a.mu.Lock()
	defer a.mu.Unlock()

	if a.running {
		return fmt.Errorf("application is already running")
	}

	a.Logger.Info(ctx, "Starting rwwwrse reverse proxy application", observability.String("version", "v1.0.0"), observability.String("address", a.Config.Server.GetServerAddress()), observability.Bool("tls_enabled", a.Config.TLS.Enabled), observability.Int("backend_count", len(a.Config.Backends.Routes)))

	a.running = true
	a.Logger.Info(ctx, "rwwwrse reverse proxy application started successfully", observability.String("status", "running"), observability.String("health_endpoint", fmt.Sprintf("%s/health", a.Config.Server.GetServerAddress())), observability.String("metrics_endpoint", fmt.Sprintf("%s/metrics", a.Config.Server.GetServerAddress())))

	return nil
}

// Stop gracefully stops all components of the application.
func (a *Application) Stop(ctx context.Context) error {
	a.mu.Lock()
	defer a.mu.Unlock()

	if !a.running {
		return nil
	}

	a.Logger.Info(ctx, "Stopping rwwwrse reverse proxy application")

	shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	_ = shutdownCtx

	a.running = false
	a.Logger.Info(ctx, "rwwwrse reverse proxy application stopped successfully")
	return nil
}

// IsRunning returns whether the application is currently running.
func (a *Application) IsRunning() bool {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.running
}

// GetStatus returns the current status of the application.
func (a *Application) GetStatus(ctx context.Context) map[string]interface{} {
	a.mu.RLock()
	defer a.mu.RUnlock()

	status := map[string]interface{}{
		"running":       a.running,
		"version":       "v1.0.0",
		"config":        a.Config.Server.GetServerAddress(),
		"tls_enabled":   a.Config.TLS.Enabled,
		"backend_count": len(a.Config.Backends.Routes),
	}

	return status
}
