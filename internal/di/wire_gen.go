// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	"fmt"
	"github.com/albedosehen/rwwwrse/internal/config"
	"github.com/albedosehen/rwwwrse/internal/observability"
	"github.com/albedosehen/rwwwrse/internal/proxy"
	"github.com/google/wire"
	"sync"
	"time"
)

// Injectors from wire.go:

// InitializeApplication creates a fully wired application instance.
// This function will be implemented by Wire code generation.
func InitializeApplication(ctx context.Context) (*Application, error) {
	configConfig, err := config.ProvideConfig()
	if err != nil {
		return nil, err
	}
	loggingConfig, err := config.ProvideLoggingConfig()
	if err != nil {
		return nil, err
	}
	logger := observability.ProvideLogger(loggingConfig)
	metricsConfig, err := config.ProvideMetricsConfig()
	if err != nil {
		return nil, err
	}
	metricsCollector := observability.ProvideMetricsCollector(metricsConfig)
	backendsConfig, err := config.ProvideBackendsConfig()
	if err != nil {
		return nil, err
	}
	router := proxy.ProvideRouter(backendsConfig, logger, metricsCollector)
	backendManager := proxy.ProvideBackendManager(backendsConfig, logger, metricsCollector)
	proxyHandler := proxy.ProvideProxyHandler(router, logger, metricsCollector)
	application := ProvideApplication(configConfig, logger, metricsCollector, router, backendManager, proxyHandler)
	return application, nil
}

// InitializeApplicationWithConfig creates a fully wired application instance with custom config.
// This function will be implemented by Wire code generation.
func InitializeApplicationWithConfig(ctx context.Context, cfg *config.Config) (*Application, error) {
	loggingConfig := config.ProvideLoggingConfigFromConfig(cfg)
	logger := observability.ProvideLogger(loggingConfig)
	metricsConfig := config.ProvideMetricsConfigFromConfig(cfg)
	metricsCollector := observability.ProvideMetricsCollector(metricsConfig)
	backendsConfig := config.ProvideBackendsConfigFromConfig(cfg)
	router := proxy.ProvideRouter(backendsConfig, logger, metricsCollector)
	backendManager := proxy.ProvideBackendManager(backendsConfig, logger, metricsCollector)
	proxyHandler := proxy.ProvideProxyHandler(router, logger, metricsCollector)
	application := ProvideApplication(cfg, logger, metricsCollector, router, backendManager, proxyHandler)
	return application, nil
}

// wire.go:

// Application represents the complete wired application.
type Application struct {
	Config     *config.Config
	Logger     observability.Logger
	Metrics    observability.MetricsCollector
	Router     proxy.Router
	BackendMgr proxy.BackendManager
	Handler    proxy.ProxyHandler

	mu      sync.RWMutex
	running bool
}

// providerSet defines the complete set of providers for dependency injection.
var providerSet = wire.NewSet(config.ProvideConfig, config.ProvideLoggingConfig, config.ProvideMetricsConfig, config.ProvideBackendsConfig, observability.ProvideLogger, observability.ProvideMetricsCollector, proxy.ProvideRouter, proxy.ProvideBackendManager, proxy.ProvideProxyHandler, ProvideApplication)

// ProvideApplication creates the main application instance.
func ProvideApplication(
	cfg *config.Config,
	logger observability.Logger,
	metrics observability.MetricsCollector,
	router proxy.Router,
	backendMgr proxy.BackendManager,
	handler proxy.ProxyHandler,
) *Application {
	return &Application{
		Config:     cfg,
		Logger:     logger,
		Metrics:    metrics,
		Router:     router,
		BackendMgr: backendMgr,
		Handler:    handler,
	}
}

// Start starts all components of the application.
func (a *Application) Start(ctx context.Context) error {
	a.mu.Lock()
	defer a.mu.Unlock()

	if a.running {
		return fmt.Errorf("application is already running")
	}

	a.Logger.Info(ctx, "Starting rwwwrse reverse proxy application", observability.String("version", "v1.0.0"), observability.String("address", a.Config.Server.GetServerAddress()), observability.Bool("tls_enabled", a.Config.TLS.Enabled), observability.Int("backend_count", len(a.Config.Backends.Routes)))

	a.running = true
	a.Logger.Info(ctx, "rwwwrse reverse proxy application started successfully", observability.String("status", "running"), observability.String("health_endpoint", fmt.Sprintf("%s/health", a.Config.Server.GetServerAddress())), observability.String("metrics_endpoint", fmt.Sprintf("%s/metrics", a.Config.Server.GetServerAddress())))

	return nil
}

// Stop gracefully stops all components of the application.
func (a *Application) Stop(ctx context.Context) error {
	a.mu.Lock()
	defer a.mu.Unlock()

	if !a.running {
		return nil
	}

	a.Logger.Info(ctx, "Stopping rwwwrse reverse proxy application")

	shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	_ = shutdownCtx

	a.running = false
	a.Logger.Info(ctx, "rwwwrse reverse proxy application stopped successfully")
	return nil
}

// IsRunning returns whether the application is currently running.
func (a *Application) IsRunning() bool {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.running
}

// GetStatus returns the current status of the application.
func (a *Application) GetStatus(ctx context.Context) map[string]interface{} {
	a.mu.RLock()
	defer a.mu.RUnlock()

	status := map[string]interface{}{
		"running":       a.running,
		"version":       "v1.0.0",
		"config":        a.Config.Server.GetServerAddress(),
		"tls_enabled":   a.Config.TLS.Enabled,
		"backend_count": len(a.Config.Backends.Routes),
	}

	return status
}
