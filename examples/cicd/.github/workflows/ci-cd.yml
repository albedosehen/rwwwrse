name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, develop ]

env:
  GO_VERSION: '1.21'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Code quality and testing
  test:
    name: Test and Quality Checks
    runs-on: ubuntu-latest
    outputs:
      coverage: ${{ steps.coverage.outputs.coverage }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Download dependencies
      run: |
        go mod download
        go mod verify

    - name: Run gofmt
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code not formatted properly:"
          gofmt -s -l .
          exit 1
        fi

    - name: Run go vet
      run: go vet ./...

    - name: Install golangci-lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        args: --timeout=5m

    - name: Run tests
      run: |
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

    - name: Calculate coverage
      id: coverage
      run: |
        COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
        echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
        echo "Test coverage: $COVERAGE%"

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        fail_ci_if_error: false

    - name: Security scan with gosec
      uses: securecodewarrior/github-action-gosec@master
      with:
        args: '-fmt sarif -out gosec-results.sarif ./...'
      continue-on-error: true

    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: gosec-results.sarif
      if: always()

  # Build application binary
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        BINARY_NAME=rwwwrse
        if [ "$GOOS" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        go build -ldflags="-w -s -X main.version=${{ github.ref_name }} -X main.commit=${{ github.sha }}" \
          -o dist/${BINARY_NAME}-${GOOS}-${GOARCH} ./cmd/rwwwrse

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: rwwwrse-${{ matrix.goos }}-${{ matrix.goarch }}
        path: dist/
        retention-days: 30

  # Build and push container image
  container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: test
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ github.ref_name }}
          COMMIT=${{ github.sha }}

    - name: Output image
      id: image
      run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}" >> $GITHUB_OUTPUT

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.image.outputs.image }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
      if: always()

  # Deploy to development environment
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [test, container]
    if: github.ref == 'refs/heads/develop' || github.event_name == 'pull_request'
    environment:
      name: development
      url: https://dev.rwwwrse.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy to Kubernetes
      run: |
        export KUBECONFIG=kubeconfig
        
        # Update image in deployment manifest
        sed -i "s|IMAGE_PLACEHOLDER|${{ needs.container.outputs.image }}|g" examples/kubernetes/minikube/deployment.yaml
        
        # Apply manifests
        kubectl apply -f examples/kubernetes/minikube/namespace.yaml
        kubectl apply -f examples/kubernetes/minikube/configmap.yaml
        kubectl apply -f examples/kubernetes/minikube/deployment.yaml
        kubectl apply -f examples/kubernetes/minikube/service.yaml
        
        # Wait for rollout
        kubectl rollout status deployment/rwwwrse -n rwwwrse-dev --timeout=300s

    - name: Run smoke tests
      run: |
        sleep 30
        curl -f https://dev.rwwwrse.example.com/health || exit 1
        curl -f https://dev.rwwwrse.example.com/metrics || exit 1

    - name: Notify deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: 'Development deployment completed for ${{ github.ref_name }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      if: always()

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [test, container, deploy-dev]
    if: github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://staging.rwwwrse.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy with Helm
      run: |
        export KUBECONFIG=kubeconfig
        
        # Install/upgrade with Helm
        helm upgrade --install rwwwrse-staging ./charts/rwwwrse \
          --namespace rwwwrse-staging \
          --create-namespace \
          --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.container.outputs.digest }} \
          --set environment=staging \
          --set ingress.hosts[0].host=staging.rwwwrse.example.com \
          --wait --timeout=10m

    - name: Run integration tests
      run: |
        # Wait for service to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=rwwwrse -n rwwwrse-staging --timeout=300s
        
        # Run comprehensive tests
        ./scripts/integration-tests.sh https://staging.rwwwrse.example.com

    - name: Performance test
      run: |
        # Basic load test
        docker run --rm -i grafana/k6:latest run - <<EOF
        import http from 'k6/http';
        import { check } from 'k6';
        
        export let options = {
          stages: [
            { duration: '2m', target: 100 },
            { duration: '5m', target: 100 },
            { duration: '2m', target: 0 },
          ],
        };
        
        export default function () {
          let response = http.get('https://staging.rwwwrse.example.com/health');
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 500ms': (r) => r.timings.duration < 500,
          });
        }
        EOF

  # Deploy to production environment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, container, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://rwwwrse.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Blue-Green Deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        # Deploy to green environment
        helm upgrade --install rwwwrse-green ./charts/rwwwrse \
          --namespace rwwwrse-prod \
          --create-namespace \
          --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.container.outputs.digest }} \
          --set environment=production \
          --set deployment.color=green \
          --set service.selector.color=green \
          --wait --timeout=15m

    - name: Health check green deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        # Wait for green deployment to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=rwwwrse,color=green -n rwwwrse-prod --timeout=300s
        
        # Test green deployment internally
        kubectl run test-pod --image=curlimages/curl:latest --rm -i --restart=Never -n rwwwrse-prod -- \
          curl -f http://rwwwrse-green:8080/health

    - name: Switch traffic to green
      run: |
        export KUBECONFIG=kubeconfig
        
        # Update main service to point to green
        kubectl patch service rwwwrse -n rwwwrse-prod -p '{"spec":{"selector":{"color":"green"}}}'
        
        # Wait a moment for traffic to switch
        sleep 30

    - name: Final health check
      run: |
        # Test production URL
        for i in {1..5}; do
          curl -f https://rwwwrse.example.com/health && break
          sleep 10
        done

    - name: Clean up blue deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        # Remove blue deployment after successful green deployment
        helm uninstall rwwwrse-blue -n rwwwrse-prod || true

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: Release ${{ github.ref_name }}
        body: |
          ## Changes
          
          ${{ github.event.head_commit.message }}
          
          ## Docker Images
          
          - `${{ needs.container.outputs.image }}`
          
          ## Deployment Info
          
          - **Commit**: ${{ github.sha }}
          - **Coverage**: ${{ needs.test.outputs.coverage }}%
          - **Deployed**: ${{ github.run_number }}
        draft: false
        prerelease: false

    - name: Notify production deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: |
          ðŸš€ Production deployment completed!
          
          **Version**: ${{ github.ref_name }}
          **Image**: ${{ needs.container.outputs.image }}
          **Coverage**: ${{ needs.test.outputs.coverage }}%
          **URL**: https://rwwwrse.example.com
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      if: always()

  # Security scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: go

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

    - name: Dependency scan
      uses: actions/dependency-review-action@v3
      if: github.event_name == 'pull_request'

  # Cleanup old artifacts
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-production, deploy-staging, deploy-dev]

    steps:
    - name: Delete old container images
      run: |
        # Keep only the last 10 images
        gh api --paginate \
          "/user/packages/container/${{ env.IMAGE_NAME }}/versions" \
          --jq '.[] | select(.metadata.container.tags | length == 0) | .id' \
        | tail -n +11 \
        | xargs -I {} gh api --method DELETE "/user/packages/container/${{ env.IMAGE_NAME }}/versions/{}"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      continue-on-error: true

    - name: Delete old workflow runs
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ github.token }}
        repository: ${{ github.repository }}
        retain_days: 30
        keep_minimum_runs: 10